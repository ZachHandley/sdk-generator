const os = require('os');
const https = require("https");
const JSONbig = require("json-bigint")({ storeAsString: false });
const FormData = require("form-data");
const {{spec.title | caseUcfirst}}Exception = require("./exception.js");
const { globalConfig } = require("./config.js");

class Client {
  static CHUNK_SIZE = 5*1024*1024; // 5MB
  
  constructor() {
    this.endpoint = '{{spec.endpoint}}';
    this.headers = {
      'content-type': '',
      'x-sdk-name': '{{ sdk.name }}',
      'x-sdk-platform': '{{ sdk.platform }}',
      'x-sdk-language': '{{ language.name | caseLower }}',
      'x-sdk-version': '{{ sdk.version }}',
      'user-agent' : `{{spec.title | caseUcfirst}}CLI/{{ sdk.version }} (${os.type()} ${os.version()}; ${os.arch()})`,
{% for key,header in spec.global.defaultHeaders %}
      '{{key}}' : '{{header}}',
{% endfor %}
    };
  }

  /**
   * Set Cookie
   *
   * Your cookie
   *
   * @param {string} cookie
   *
   * @return self
   */
  setCookie(cookie) {
    this.addHeader("cookie", cookie);

    return this;
  }

{% for header in spec.global.headers %}
    /**
     * Set {{header.key | caseUcfirst}}
     *
{% if header.description %}
     * {{header.description}}
     *
{% endif %}
     * @param {string} {{header.key | caseLower}}
     *
     * @return self
     */
    set{{header.key | caseUcfirst}}({{header.key | caseLower}}) {
        this.addHeader('{{header.name}}', {{header.key | caseLower}});

        return this;
    }

{% endfor %}
  /**
   * Set self signed.
   *
   * @param {bool} status
   *
   * @return this
   */
  setSelfSigned(status) {
    this.selfSigned = status;

    return this;
  }

  /**
   * Set endpoint.
   *
   * @param {string} endpoint
   *
   * @return this
   */
  setEndpoint(endpoint) {
    this.endpoint = endpoint;

    return this;
  }

  /**
   * @param {string} key
   * @param {string} value
   */
  addHeader(key, value) {
    this.headers[key.toLowerCase()] = value;

    return this;
  }

  async call(
    method,
    path = "",
    headers = {},
    params = {},
  ) {
    headers = Object.assign({}, this.headers, headers);

    let options = {
      method: method.toUpperCase(),
      headers: headers,
      credentials: "include",
    };

    if (method.toUpperCase() === "GET") {
      if (Object.keys(params).length > 0) {
        path =
          path + "?" + new URLSearchParams(Client.flatten(params)).toString();
      }
    } else {
      switch (headers["content-type"]) {
        case "application/json":
          options.body = JSONbig.stringify(params);
          break;
        case "multipart/form-data":
          let formData = new FormData();

          for (const key in params) {
            if (Array.isArray(params[key])) {
              params[key].forEach((value) => {
                formData.append(key + "[]", value);
              });
            } else {
              formData.append(key, params[key]);
            }
          }

          options.body = formData;
          delete headers["content-type"];
          break;
      }
    }

    if (this.selfSigned == true) {
      // Allow self signed requests
      process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = 0;
    }

    try {
      let data = null;
      const response = await fetch(this.endpoint + path, options);

      if (response.headers.get("content-type")?.includes("application/json")) {
        data = JSONbig.parse(await response.text());
      } else {
        data = {
          message: await response.text(),
        };
      }

      if (400 <= response.status) {
        throw new {{spec.title | caseUcfirst}}Exception(
          data?.message,
          response.status,
          data?.type,
          data
        );
      }

      if (response.headers["set-cookie"]) {
        globalConfig.setCookie(response.headers["set-cookie"][0]);
      }

      return data;
    } catch (e) {
      if (e instanceof {{spec.title | caseUcfirst}}Exception) {
        throw e;
      } else {
        throw new {{spec.title | caseUcfirst}}Exception(e.message);
      }
    }
  }

  static flatten(data, prefix = "") {
    let output = {};

    for (const key in data) {
      let value = data[key];
      let finalKey = prefix ? prefix + "[" + key + "]" : key;

      if (Array.isArray(value)) {
        output = Object.assign(output, Client.flatten(value, finalKey)); // @todo: handle name collision here if needed
      } else {
        output[finalKey] = value;
      }
    }

    return output;
  }
}

module.exports = Client;
